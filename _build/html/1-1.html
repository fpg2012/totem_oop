

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>面向对象起步 &mdash; totem_oop  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="totem_oop  documentation" href="index.html"/>
        <link rel="next" title="类的各种成员" href="1-2.html"/>
        <link rel="prev" title="写在前面" href="0.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> totem_oop
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0.html">写在前面</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">面向对象起步</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">定义和使用类/结构体</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">关于类和结构体声明和定义的位置</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id4">构造函数和析构函数初探</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">构造函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">拷贝构造函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">析构函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id8">访问控制与友元</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">访问控制</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">友元</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">题外话：封装的好处</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="1-2.html">类的各种成员</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">totem_oop</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>面向对象起步</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/1-1.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>面向对象起步<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>定义和使用类/结构体<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>在讲定义和使用前，我先按照我的理解解释一下为什么要有类(class)和结构体(struct)。
假设你正在写一个学生管理程序，每个学生都有自己的姓名、性别、籍贯、电话号码、历次的考试成绩……一堆东西，于是你的代码写起来会是这个样子的：</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="c1">// 只展示有用的部分</span>

<span class="c1">// 学生最大数量</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">kMax</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
<span class="c1">// 姓名，电话和籍贯</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">name</span><span class="p">,</span> <span class="n">tel</span><span class="p">,</span> <span class="n">birthplace</span><span class="p">;</span>
<span class="c1">// 历次考试成绩</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
<span class="c1">// 性别，不要使用vector&lt;bool&gt;，这是个坑！</span>
<span class="kt">bool</span> <span class="n">sex</span><span class="p">[</span><span class="n">kMax</span><span class="p">];</span>

<span class="c1">// 输出第i个学生的名字等信息</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;姓名: %s</span><span class="se">\n</span><span class="s">电话: %s</span><span class="se">\n</span><span class="s">籍贯: %s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">tel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">birthplace</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">());</span>
</pre></div>
</div>
<p>这样写似乎能够应付只是简单存储的情况。但是，如果你要按照名字字典序给学生们排序，那就很蛋疼了（并不是做不到，而是没有必要那样做）。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">默认的标准库中对 vector&lt;bool&gt; 进行了奇怪的封装，在内部实现中，每一个 bool 对应的是一个 bit 而非 byte 。
这可能导致我们无法进行一些正常操作：一个 bit 是无法创建指针和引用的。
如果需要与 vector&lt;bool&gt; 一样省空间的 bool 队列，可以使用 bitcase ，反之可以使用 deque&lt;bool&gt;。</p>
</div>
<p>于是，出现了结构体来应付这种情况，上面的代码可以写成下面那样</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="c1">// 使用struct关键字定义一个Student结构体，这个Student是我们自己定义的类型</span>
<span class="c1">// 强调！struct后面的分号一定不能漏！！！</span>
<span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">tel</span><span class="p">,</span> <span class="n">birthplace</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">sex</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// ←_← 就是这个分号</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">students</span><span class="p">;</span>

<span class="c1">// 跟前面一样</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;姓名: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="c1">// 排序，要先定义一下比较的谓词cmp，这里不赘述，假设已经定义好了</span>
<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">students</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">students</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">结构体定义后面的分号一定不能漏。大家可以故意漏写一次看看会报什么错。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>cmp的定义如下</p>
<div class="code c++ last highlight-cpp"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">Student</span> <span class="n">a</span><span class="p">,</span> <span class="n">Student</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<p>大家应该已经注意到了，结构体将各种不同的数据“结合”在了一起，构成了一个新的类型<code class="docutils literal"><span class="pre">Student</span></code>。我们可以像内置类型一样定义自己的<code class="docutils literal"><span class="pre">Student</span></code>变量，一个<code class="docutils literal"><span class="pre">Student</span></code>变量就是一个<code class="docutils literal"><span class="pre">Student</span></code>类型的实例。使用点操作符可以访问结构体中的某个成员(member)。上面用到的成员都是数据成员，数据成员也叫属性(attribute)。成员使用”<code class="docutils literal"><span class="pre">.</span></code>”操作符来访问。属性访问起来跟普通的变量没什么区别。例子在下面。</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="c1">// 定义一个Student变量</span>
<span class="n">Student</span> <span class="n">student_a</span><span class="p">;</span>
<span class="c1">// 输入一个名字，标准库string类型不要用scanf</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">student_a</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="c1">// 获取它的name</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_a</span> <span class="o">=</span> <span class="n">student_a</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="c1">// 改变它的tel</span>
<span class="n">student_a</span><span class="p">.</span><span class="n">tel</span> <span class="o">=</span> <span class="s">&quot;10086&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>使用结构体相比使用一大堆数组，思路更加清晰和自然。</p>
<p>但是，现在出现了新的问题。</p>
<p>我们知道，学生的results属性中保存的是学生多次考试的成绩（假设这个学生只学一个科目233），现在校领导想获得每个学生的平均分。有些人也许会这样实现：</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="c1">// ...</span>

<span class="c1">// 返回学生的平均分</span>
<span class="kt">double</span> <span class="nf">getAverage</span><span class="p">(</span><span class="n">Student</span> <span class="n">student</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">marks</span> <span class="p">:</span> <span class="n">student</span><span class="p">.</span><span class="n">results</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">marks</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">auto</span> <span class="n">beg</span> <span class="o">=</span> <span class="n">student</span><span class="p">.</span><span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">student</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">sum</span> <span class="o">/</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">beg</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="c1">// 输出所有学生的平均分</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">stu</span> <span class="p">:</span> <span class="n">students</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s的平均分: %lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stu</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">getAverage</span><span class="p">(</span><span class="n">stu</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</pre></div>
</div>
<p>这样做看起来在小程序中还不错，但是在C++中，有更好更自然的方法</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Student</span> <span class="p">{</span>
  <span class="c1">// ... 和前面一样</span>
  <span class="kt">double</span> <span class="n">getAverage</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// ... 不再赘述</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ...</span>

<span class="c1">// 获取一个名为stu的Student变量的平均分</span>
<span class="n">stu</span><span class="p">.</span><span class="n">getAverage</span><span class="p">();</span>

<span class="c1">// ...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">这个例子只是为了引入，大家看看就好，Google的代码风格要求在<strong>只有</strong>数据成员时才使用结构体，否则使用class。我们后面会讲。</p>
</div>
<p>我们在结构体中定义了<code class="docutils literal"><span class="pre">getAverage()</span></code>函数，这个函数也是结构体的成员，叫做成员函数，也叫方法(method)。</p>
<p>用类也可以做到上面的效果，事实上struct定义的结构体也是类。类的定义使用<code class="docutils literal"><span class="pre">class</span></code>关键字。<code class="docutils literal"><span class="pre">public:</span></code>表示以下的部分可以被外部访问，<code class="docutils literal"><span class="pre">private</span></code>表示以下成员只能被类的其他成员访问。struct中默认都是
<code class="docutils literal"><span class="pre">public</span></code>的，而class则默认是<code class="docutils literal"><span class="pre">private</span></code>的。</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// ... 和前面一样</span>
  <span class="kt">double</span> <span class="n">getAverage</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// ... 不再赘述</span>
  <span class="p">}</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">favorate_book</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Student</span> <span class="n">temp</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">temp_str</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">favorate_book</span><span class="p">;</span> <span class="c1">// 错误</span>
<span class="n">temp</span><span class="p">.</span><span class="n">favorate_book</span> <span class="o">=</span> <span class="s">&quot;Nineteen Eighty-four&quot;</span><span class="p">;</span> <span class="c1">// 错误</span>
</pre></div>
</div>
<div class="section" id="id3">
<h3>关于类和结构体声明和定义的位置<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>声明和定义一般都放在头文件(header
files)中，也就是<code class="docutils literal"><span class="pre">*.h</span></code>文件。类的成员的定义却要放在源文件中(source
files)，即<code class="docutils literal"><span class="pre">.cc</span></code>/<code class="docutils literal"><span class="pre">.cpp</span></code>/<code class="docutils literal"><span class="pre">.cxx</span></code>文件中（谷歌的风格使用<code class="docutils literal"><span class="pre">.cc</span></code>）。下面举个例子。(
ps. 后面为了演示方便示例代码可能不会这样写</p>
<p>foo.h中</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="cp">#ifndef FOO_H</span>
<span class="cp">#define FOO_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Project</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">bar</span><span class="p">();</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">a_</span><span class="p">,</span> <span class="n">b_</span><span class="p">,</span> <span class="n">c_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">d_</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>foo.cc中</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&quot;foo.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">Project</span><span class="o">::</span><span class="n">Foo</span><span class="o">::</span><span class="n">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="c1">// ...</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Google的代码风格要求把所有的数据成员定义为
<code class="docutils literal"><span class="pre">private</span></code>的，并且在数据成员标识符后面加上”<code class="docutils literal"><span class="pre">_</span></code>”。</p>
</div>
</div>
</div>
<div class="section" id="id4">
<h2>构造函数和析构函数初探<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id5">
<h3>构造函数<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>前面已经初步提到了类的<code class="docutils literal"><span class="pre">public</span></code>部分和<code class="docutils literal"><span class="pre">private</span></code>部分。现在我们想要在一开始就给某个<code class="docutils literal"><span class="pre">Student</span></code>对象赋予其名字。我们可以使用构造函数(constructor)。在使用<code class="docutils literal"><span class="pre">Student</span></code>做例子之前，先看一个更简单的例子。</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 这就是构造函数</span>
  <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">a_</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b_</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">c_</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">d_</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Constructor!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">getA</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// ... BCD略</span>
  <span class="kt">void</span> <span class="n">setA</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a_</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// ... BCD略</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">a_</span><span class="p">,</span> <span class="n">b_</span><span class="p">,</span> <span class="n">c_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">d_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 定义一个Foo类型的变量</span>
<span class="n">Foo</span> <span class="nf">foo</span><span class="p">(</span><span class="mi">233</span><span class="p">,</span> <span class="mi">2333</span><span class="p">,</span> <span class="mi">666</span><span class="p">,</span> <span class="s">&quot;8964&quot;</span><span class="p">);</span> <span class="c1">// 这里调用完后会输出 Constructor!</span>
<span class="n">foo</span><span class="p">.</span><span class="n">getA</span><span class="p">();</span> <span class="c1">// 结果为233</span>
<span class="n">foo</span><span class="p">.</span><span class="n">getB</span><span class="p">();</span> <span class="c1">// 结果为2333</span>
<span class="n">foo</span><span class="p">.</span><span class="n">getC</span><span class="p">();</span> <span class="c1">// 结果为666</span>
<span class="n">foo</span><span class="p">.</span><span class="n">getD</span><span class="p">();</span> <span class="c1">// 结果为&quot;8964&quot;</span>
</pre></div>
</div>
<p>很明显，<code class="docutils literal"><span class="pre">Foo()</span></code>就是我们的构造函数。构造函数后面那一串东西叫做初始化列表。例如<code class="docutils literal"><span class="pre">a_(a)</span></code>的意思就是把构造函数参数<code class="docutils literal"><span class="pre">a</span></code>赋给当前对象的属性<code class="docutils literal"><span class="pre">a_</span></code>。我们在初始化时利用变量标识符后面那一串括号来调用构造函数。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">这个例子中函数的定义照理说应该放在源文件中，而不是和类一起放在头文件里。由于我们把每个数据成员都定义为<code class="docutils literal"><span class="pre">private</span></code>的，所以如果需要在类外读取，只好定义一个名为<code class="docutils literal"><span class="pre">getXXX()</span></code>的成员函数来实现。同理，如果要在类外修改，只好定义一个名为<code class="docutils literal"><span class="pre">setXXX()</span></code>的成员函数来实现。这叫做存取控制，也叫封装。</p>
</div>
</div>
<div class="section" id="id6">
<h3>拷贝构造函数<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>拷贝构造函数其实非常简单，就是用一个同类型的对象来构造自己，例如</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="c1">// 我们的拷贝构造函数，一般这样放着就行了</span>
  <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="n">Foo</span> <span class="nf">foo1</span><span class="p">(</span><span class="mi">233</span><span class="p">,</span> <span class="mi">2333</span><span class="p">,</span> <span class="mi">666</span><span class="p">,</span> <span class="s">&quot;sb&quot;</span><span class="p">);</span>
<span class="n">Foo</span> <span class="nf">foo2</span><span class="p">(</span><span class="n">foo1</span><span class="p">);</span>
<span class="n">foo2</span><span class="p">.</span><span class="n">getD</span><span class="p">()</span> <span class="c1">// 结果为sb</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>析构函数<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>析构函数(destructor)，顾名思义，就是在对象被析构的时候调用的。它可以进行一些“善后”的操作。但是到现在为止我写过的析构函数要么是空的，要么<code class="docutils literal"><span class="pre">=</span> <span class="pre">default</span></code></p>
<p>还是上面那个例子，在上面那段代码的构造函数后面加上一行：</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="c1">// 使用编译器自动合成的构造函数</span>
<span class="n">Foo</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="c1">// 这就是析构函数</span>
<span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Destructor!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p>然后这样用</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Foo</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>就能看到输出是这样的</p>
<div class="code highlight-cpp"><div class="highlight"><pre><span class="n">Destructor</span><span class="o">!</span>
<span class="n">Destructor</span><span class="o">!</span>
<span class="n">Destructor</span><span class="o">!</span>
<span class="n">Destructor</span><span class="o">!</span>
<span class="n">Destructor</span><span class="o">!</span>
</pre></div>
</div>
<p>由于变量每次离开作用域都要被析构一次，循环了5次，所以调用了五次析构函数。这也是为什么Google的代码风格要求：如果是在循环中的这种临时的类对象，最好放在循环体外面——放在里面的话，要调用好多次析构函数，十分浪费时间。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">关于给<code class="docutils literal"><span class="pre">Student</span></code>类定义构造函数和析构函数，留给读者自己实现。构造函数和析构函数我们过后还会再涉及。</p>
</div>
</div>
</div>
<div class="section" id="id8">
<h2>访问控制与友元<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id9">
<h3>访问控制<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>访问控制之前已经提到过了，就是<code class="docutils literal"><span class="pre">public</span></code>/<code class="docutils literal"><span class="pre">private</span></code>这些的。当然还有一个<code class="docutils literal"><span class="pre">protected</span></code>，这个我们以后再提。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">这里必须强调一下，如果一个成员函数只会在类中被调用，请定义成<code class="docutils literal"><span class="pre">private</span></code>。数据成员全部定义为私有，并进行访问控制。不要把所有东西都丢到<code class="docutils literal"><span class="pre">public</span></code>里面去。</p>
</div>
</div>
<div class="section" id="id10">
<h3>友元<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>有的时候我们会碰到一种情况，必须让少数类外的函数能够访问类的<code class="docutils literal"><span class="pre">private</span></code>部分。这个时候就需要用到友元(friend)了。</p>
<p>友员函数声明，就是声明允许某个非成员函数访问类的的<code class="docutils literal"><span class="pre">private</span></code>部分。</p>
<p>声明友元使用<code class="docutils literal"><span class="pre">friend</span></code>关键字。</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="c1">// 友元声明</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">compare1</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Foo</span> <span class="n">b</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>foo.cc的某处</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="c1">// 以下分别是对compare1与compare2的定义，不难看出两个函数实际上是一样的</span>
<span class="c1">// 差别在与compare1有在类中进行友元声明，而compare2没有</span>
<span class="n">Project</span><span class="o">::</span><span class="n">compare1</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Foo</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">a_</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">b_</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">a_</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">b_</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Project</span><span class="o">::</span><span class="n">compare2</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Foo</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">a_</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">b_</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">a_</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">b_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>main.cc的某处，我们在这里使用compare1和compare2</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="c1">// 定义两个Foo变量</span>
<span class="n">Foo</span> <span class="nf">a</span><span class="p">(</span><span class="mi">233</span><span class="p">,</span> <span class="mi">666</span><span class="p">,</span> <span class="mi">8964</span><span class="p">,</span> <span class="s">&quot;sb&quot;</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;aaa&quot;</span><span class="p">);</span>
<span class="c1">// 这里我们使用compare</span>
<span class="n">compare1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// 没有错误，由于233 + 666 &gt; 0 + 0，所以结果为true</span>
<span class="n">compare2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// 错误，这个函数根本没有办法读取a和b的私有部分</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">ps. 这个例子举的不好，大家只要明白友元怎么用就行了。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">什么东西都不能滥用。我相信应该没有人会把一个类所有的成员都定义成私有的，然后再声明一堆朋友233</p>
</div>
<p>我们还可以制定其他类的成员函数为友元，使其可以访问本类的私有成员。用法与上面指定某函数为友元大致相同。</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="c1">// Bar类的前置声明，使Foo类可以使用Bar类</span>
<span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">func1</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">a_</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">b_</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">c_</span><span class="p">);</span>
   <span class="p">}</span>
  <span class="kt">void</span> <span class="n">func2</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">a_</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">b_</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">c_</span><span class="p">);</span>
  <span class="p">}</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">a_</span><span class="p">,</span> <span class="n">b_</span><span class="p">,</span> <span class="n">c_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
   <span class="k">friend</span> <span class="n">Foo</span><span class="o">::</span><span class="n">func1</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span> <span class="n">a</span><span class="p">);</span>
   <span class="c1">// ... 省略一堆getXXX和setXXX</span>
 <span class="k">private</span><span class="o">:</span>
   <span class="kt">int</span> <span class="n">a_</span><span class="p">,</span> <span class="n">b_</span><span class="p">,</span> <span class="n">c_</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Foo</span> <span class="n">a</span><span class="p">;</span>
<span class="n">Bar</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="p">.</span><span class="n">setA</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">b</span><span class="p">.</span><span class="n">setB</span><span class="p">(</span><span class="mi">233</span><span class="p">);</span>
<span class="n">b</span><span class="p">.</span><span class="n">setC</span><span class="p">(</span><span class="mi">438</span><span class="p">);</span>
<span class="n">a</span><span class="p">.</span><span class="n">func1</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 正确，将输出 100 233 438</span>
<span class="n">a</span><span class="p">.</span><span class="n">func2</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 错误，不能访问Bar类的私有部分</span>
</pre></div>
</div>
<p>我们甚至可以直接指定某个类为友元，其意义是整个类作用域中的函数都是友元。还是上面那个例子。</p>
<div class="code c++ highlight-cpp"><div class="highlight"><pre><span class="c1">// Bar类的前置声明，使Foo类可以使用Bar类</span>
<span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">func1</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">a_</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">b_</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">c_</span><span class="p">);</span>
   <span class="p">}</span>
  <span class="kt">void</span> <span class="n">func2</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">a_</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">b_</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">c_</span><span class="p">);</span>
  <span class="p">}</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">a_</span><span class="p">,</span> <span class="n">b_</span><span class="p">,</span> <span class="n">c_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
   <span class="k">friend</span> <span class="k">class</span> <span class="nc">Foo</span><span class="p">;</span>
   <span class="c1">// ... 省略一堆getXXX和setXXX</span>
 <span class="k">private</span><span class="o">:</span>
   <span class="kt">int</span> <span class="n">a_</span><span class="p">,</span> <span class="n">b_</span><span class="p">,</span> <span class="n">c_</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Foo</span> <span class="n">a</span><span class="p">;</span>
<span class="n">Bar</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="p">.</span><span class="n">setA</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">b</span><span class="p">.</span><span class="n">setB</span><span class="p">(</span><span class="mi">233</span><span class="p">);</span>
<span class="n">b</span><span class="p">.</span><span class="n">setC</span><span class="p">(</span><span class="mi">438</span><span class="p">);</span>
<span class="n">a</span><span class="p">.</span><span class="n">func1</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 正确，将输出 100 233 438</span>
<span class="n">a</span><span class="p">.</span><span class="n">func2</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 正确，将输出 100 233 438</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>题外话：封装的好处<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>直接引用C++ Primer</p>
<blockquote>
<div><p>封装有两个重要的优点：</p>
<ul class="simple">
<li>确保用户代码不会无意间破坏封装对象的状态。</li>
<li>被封装的类具体实现可以随时改变，而无须调整用户级别的代码</li>
</ul>
</div></blockquote>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="1-2.html" class="btn btn-neutral float-right" title="类的各种成员" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="0.html" class="btn btn-neutral" title="写在前面" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, segmentation fault.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>